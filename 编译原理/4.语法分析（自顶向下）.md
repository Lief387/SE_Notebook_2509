### 4.4自顶向下分析

[编译原理期末速成bilibili——P1-4](https://www.bilibili.com/video/BV12a41167j9/?spm_id_from=333.1387.upload.video_card.click&vd_source=91393d9709ce53cabe55a09644afd371)

核心思想：从开始符号出发，应用产生式，尝试推导出于输入（Token流)完全匹配的句子。有两种实现算法：

#### 递归下降算法

递归下降是一种**自顶向下**的语法分析算法，其是否回溯需要根据文法的性质决定（如LL(1)文法不需要），无法处理左递归文法。

对于不需要回溯的文法，递归下降的实现如下（即预测性解析Predictive parsing）

**核心思想：**

- 每一个非终结符构造一个**分析函数**parse_N()
- **前看符号**指导产生式选择

**工作流程**（在一个Parse_N()内部）：

1. **选择产生式**，查看当前**前看符号**，即输入流中下一个Token，根据Token来决定选择哪一个产生式。 $A \to X_1X_2...X_n$
2. 匹配产生式体：
	1. 如果 $X_i$ 是一个**非终结符**，则**递归调用**对应分析函数
	2. 如果 $X_i$ 是一个**终结符**，将其与当前输入Token进行**匹配**。若匹配成功，则消耗Token，输入指针后移
	3. 若不匹配，则报告语法错误
	**优点**：线性时间，实现逻辑简单

```c  file:递归下降 fold
void A() {
    // 1) 选择一个 A 的产生式, A -> X1 X2 ... Xk;
    Choose an A-production, A -> X1 X2 ... Xk;
    // 2) for (i = 1 to k) {
    for (i = 1 to k) {
        // 3) if (Xi 是一个非终结符)
        if (Xi is a nonterminal) {
            // 4) 调用 Xi();
            call procedure Xi();
        // 5) else if (Xi 等于当前的输入符号 a)
        } else if (Xi equals the current input symbol a) {
            // 6) 将输入指针移到下一个符号;
            advance the input to the next symbol;
        // 7) else /* 发生错误 */;
        } else /* an error has occurred */;
    }
}
```
#### LL(1)分析

**名称含义**：从左（L）向右读入程序，最左（L）推导，采用一个前看符号(1)
核心思想：不使用递归函数调用，而是利用一个**分析栈**和一个预先计算好的**分析表**驱动分析过程。

- 分析表是关键
	- **列**：非终结符+“#”，**行**：终结符，
	- **项**：存放当前栈顶为终结符A且输入为终结符t时，应该使用的产生式
	**LL(1)文法**：若表中每一项只有一条产生式，则成为LL(1)文法
	若表中每一项有多种可能，则出现冲突

>**构造LL(1)分析表关键：三个集合的计算**
>根据下一个输入符号，结合First和Follow集合选择需要应用的产生式
##### LL(1)文法

两种等价说法：

- 无二义性，不含左递归，不含回溯
- 分析表中不存在冲突项

###### 判断是否是LL(1)文法

核心思想：**检查文法中的每一个终结符，确保在分析表中不会产生冲突**

一个**上下文无关文法**是**LL(1)文法**的充要条件（判断一个文法是否是LL(1)文法）：对每一个非终结符 \(A\) 的任何两个不同的产生式 \( $A \rightarrow \alpha \mid \beta$ \)，有下面条件（都是避免了多重入口）成立：

1. 若 $\beta$ 不能推出空串， $\text{FIRST}(\alpha) \cap \text{FIRST}(\beta) = \emptyset$ ： $A$ 的每个候选式都不存在相同的首字符。
2. 若 $\beta$ 可以推出空串 ，则有 $\text{FIRST}(\alpha) \cap \text{FOLLOW}(A) = \emptyset$ ：（用 $\alpha$ 推出推出的第一个字符，是A之后看你出现的终结符）避免了在分析表同一栏目内出现 $A \rightarrow \alpha$ 和 $A \rightarrow \varepsilon$ 的情况。

> 具体来讲，观察题目所给文法，是否存在一个非终结符有多个产生式
>
> - 若存在，则执行以下两个判断
>   - 若没有推导出空串的产生式，保证 $\text{FIRST}(\alpha) \cap \text{FIRST}(\beta) = \emptyset$ 
>   - 若有推导出空串的产生式，如$\beta$ 可以推出空串， 保证$\text{FIRST}(\alpha) \cap \text{FOLLOW}(A) = \emptyset$
> - 若不存在，是LL(1)文法

##### Nullable集合

- **定义**：文法中所有能推导出**空串**的非终结符集合
- **作用**：计算First和Follow集合基础
##### First集合

- **定义First(N)**：从非终结符N出发，所能推导出所有字符串的**第一个终结符**的集合
- **计算规则**：看产生式左边
	- **基本情况**：若 $N\to a\cdots$ ，则a在First(N)中。
	- **扩展情况**：若 $N \to Y_1Y_2\cdots$ ，则First( $Y_1$ )（除空串）在First(N)中。若 $Y_1$ 是Nullable的，则First ($Y_2$ )（除空串）在First(N)中，以此类推。
- **分析表中的作用**：对于产生式 $A\to a$ ，将这条产生式填入分析表所有M\[A,t]中，其中t是First(a)里每一个终结符
> 具体做法，求解First集合看产生式左边
>
> - 如果非终结符A推导出一个终结符a开头的产生式，则加入a
> - 如果非终结符A推导出一个非终结符B开头的产生式
>   - Step1,将B的First加入A
>   - Step2,观察B的First集合中是否有空串，若有，则穿透至后面的符号，继续判断

##### Follow集合

- **定义Follow(N)**：在文法所有合法句型中，可能跟在非终结符N后面的终结符集合
- **计算规则**：看产生式右边
	1. 若S是开始符号， Follow(S) += \{\#\}​
	2. 若存在产生式， $B->\alpha A \beta$ ，则  $Follow(A)+=First(\beta)-{\varepsilon}$ 
	3. $\text{若有}B \to \alpha A\text{或}B \to \alpha A\beta, \text{且}\beta \stackrel{*}{\Rightarrow} \varepsilon $则  $Follow(A)+=Follow(B)$
	4. 直至 $FollowA$ 不再增大
- **分析表中的作用**：如果一个产生式 $A\to a$ 能够推导出空串，即空串在First(a)中，那么对于Follow(A)中的每一个终结符t，都需要将产生式 $A\to a$ （通常表示为 $A\to \varepsilon$ ）填入M\[A,t]中，这解决了当A消失后，程序应该如何继续匹配的问题。

> 具体做法，求解Follow集合看产生式右边
>
> - Step1开始符号+{#}
> - Step2观察是否有A直接跟终结符a或非终结符B
>   - 将终结符a，非终结符B的First集合减去空串，加入Follow(A)
> - Step3观察是否有A暴露在产生式右部最右边（直接暴露，间接暴露）
>   - 将产生式左侧非终结符B的Follow集合加入Follow(A)

##### 构造LL(1)分析表

For each production *A* → *α* of the grammar, do the following:

1. For each terminal $\alpha$ in FIRST (*A* ), add $A\to\alpha$  to *M* [*A* , *a* ].
2. If $\varepsilon$  is in FIRST ( $\alpha$  ), then for each terminal *b* in FOLLOW (*A* ), add $A\to\alpha$ to *M* [*A* , *b* ]. If $\varepsilon$  is in FIRST ( $\alpha$  ) and $\$$ is in FOLLOW(A)，add $A\to\alpha$ to M[A,\$]as well.

> 对于First集合中的终结符 $\alpha$ ，把对应的产生式加入M[A, $\alpha$ ]
>
> 如果First集合中有空串，检查Follow集合中的终结符b，将产生空串的产生式加入M[A,b]



